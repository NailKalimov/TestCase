'''Здачка 1:

Напишите функцию f(s), которая получает на вход строку s из символов 'П' и 'С', 
обозначающих подъём (П) и спуск (С) на одну условную высоту. Начальная высота — 0.

Нужно вернуть количество участков, где путь возвращается на высоту 0 после 
движения вверх, но при этом в промежутке никогда не опускался ниже 0.
Объяснение:
• ППСС — цикл на 0, не уходит в минус ⇒ считается (1)
• ПС — 0, но с переходом вниз ⇒ не считается
• остальные — не возвращаются на 0 ⇒ не считаются

Ограничения:
• Нельзя использовать import, списки, множества, классы, глобальные переменные.
• Можно использовать только str, int, range, print, len.
'''
def f(s: str)->int:
    height = 0
    res = 0
    for ch in s:
        previous_height = height
        if ch == "П":
            height += 1
        elif ch == "С":
            height -= 1
        if previous_height > height and height == 0:
            res += 1
    return res


print(f("ППСС"))

'''
Задачка 2:
Реализуйте короткую функцию f(n) на Python со следующей логикой:
• Если n > 100, функция возвращает n - 10.
• Иначе (то есть при n <= 100), функция возвращает результат f(f(n + 11)) 
(рекурсивный двойной вызов).

Особенности решения:
• Без ввода данных: все значения (включая исходный n) должны быть заданы 
в коде как константы.
• Без сторонних библиотек: используйте только стандартный Python (библиотеку 
math и прочие подключать не нужно).
• Лаконичность кода: постарайтесь уложиться в одну функцию или скрипт до 15 строк.

Задача: Напишите эту функцию f(n) и продемонстрируйте её работу на каком-нибудь 
тестовом значении, например n = 50. Убедитесь, что функция корректно 
выполняется и завершается.
'''
def f(n: int)->int:
    if n > 100:
        return n-10
    else:
        return f(f(n+11))


n = 103
print(f(n))

'''
Задачка 3:
Реализуйте функцию is_power_of_two(n), которая получает натуральное 
число n и возвращает True, если n является точной степенью числа 2 
(то есть n = 2^k, где k — целое ≥ 0), иначе Falsе 
is_power_of_two(1) # → True (2^0)
is_power_of_two(2) # → True (2^1)
is_power_of_two(3) # → False
is_power_of_two(8) # → True (2^3)
is_power_of_two(10) # → False
Ограничения:
• Запрещено использовать: import, math, pow(), строки, логарифмы.
• Можно использовать только: int, range, while, print, and, or, not, 
побитовые операции (&, |, ^, <<, >>).
• Решение должно работать за константное или логарифмическое время, без деления 
(/, //, % — тоже нельзя).
'''
# Первое решение основано на свойствах бинарной системы исчисления и переполнении разрядов
# Пример степеней двойки в бинарном виде:
# print([bin(2**i) for i in range(20)])
# Решение
def is_power_of_two(n: int)->bool:
    flag = True
    bin_n = bin(n)[2:]
    if bin_n[0] != '1':
        flag = False
    for ch in bin_n[1:]:
        if ch != '0':
            flag = False
    return flag


# print(*enumerate([is_power_of_two(i) for i in range(33)]))


# Решение с использованием логического оператора &
# Пример:
# 0b1000 - 1 = 0b0111
# 0b1000 & 0b0111 = 0b0000
def is_power_of_two(n: int)->bool:
    return n > 0 and n & (n-1) == 0


# print(*enumerate([is_power_of_two(i) for i in range(33)]))

'''
Задачка 4:
Доработать функцию в задании 3 так, чтобы она возвращала True, если натуральное 
число n является точной степенью натурального числа k (то есть n = k^m, 
где m — целое число ≥ 0), иначе False.
is_power(1, 2) # → True (2^0)
is_power(8, 2) # → True (2^3)
is_power(9, 3) # → True (3^2)
is_power(10, 3) # → False
is_power(81, 3) # → True (3^4)
is_power(125, 5) # → True (5^3)
Ограничения:
• Запрещено использовать: import, math, pow, , log, str.
• Нельзя использовать: //, %, / — никаких делений или остатка.
• Разрешено: int, while, if, range, *, ==, !=, print, and, or, not, побитовые 
операции (&, |, ^, <<, >>).
'''

def is_power(n:int, k:int) -> bool:
    mul = k
    if n == 1:
        return True
    while mul < n:
        mul = mul * k
    if mul != n:
        return False
    return True

# print(is_power(125, 5))

'''
Задачка 5:
Пять программистов переходят ночью мост. Есть только один фонарик. 
По мосту могут идти максимум двое одновременно, и обязательно с фонариком. 
У каждого своя скорость: 1 минута, 2, 4, 7 и 10 минут соответственно. 
Когда идут вдвоём, двигаются со скоростью более медленного. 
Как им переправиться всем за минимальное время и чему оно равно?
'''
# Решение 
'''Т.к. фонарик один, его придется кажждый раз возвращать обратно одному из 
членов команды. Возникает идея минимизировать время на обратный путь посылая в 
обратную дорогу самого быстрого человека.
Тогда получается следующее решение:
1,2,4,7,10-0 -> 2,4,7-1,10 -> 1,2,4,7-10 -> 2,4-1,7,10 -> 1,2,4-7,10 (19 мин.)->
2-1,4,7,10 -> 1,2-4,7,10 -> 0-1,2,4,7,10
при котором общее время на переход составляет 10 + 1 + 7 + 1 + 4 + 1 + 2 = 26.
Видно, что наибольший вклад дают самые медленные члены команды. Возникает идея
переправлять двух медленных ребят одновременно, но тогда нужно позаботиться, чтобы
на второй стороне уже был быстрый человек, который вернет фонарь, чтобы остальные 
смогли продолжить переправу. Получаем такое решение:
1,2,4,7,10-0 -> 4,7,10-1,2 -> 1,4,7,10-2 -> 1,4-2,7,10 -> 1,2,4-7,10 (15 мин.)->...
если сравнить данное состояние из первого и второго решений, то видим, что мы сэкономили 4 минуты,
остальная часть решения остается той же. Т.е.
... 2-1,4,7,10 -> 1,2-4,7,10 -> 0-1,2,4,7,10. Общее лучшее время получилось 22 минуты.
Делал подбором, допускаю, что существует более оптимальный вариант.
'''

'''
Задачка 6:
Как разрезать круглый торт тремя прямыми разрезами так, чтобы получилось максимально возможное количество кусочков? Сколько кусочков получится?
'''
# Решение
'''
Первый разрез делается в единственном варианте. Второй разрез может пересекать первый
или нет. Во втором случае количество кусков увеличивается на 1, а в первом в 2 раза.
Соответственно рождается предположение, что для достижения максимального количества 
кусочков нужно новым разрезом стараться пересечь максимальное количество сделанных разрезов.

\    /
------
  \/
  /\
При такой схеме реза 3 движениями получается сделать 7 кусков. Если же делить 
просто по диагонали, то получается 6.

P.s.: если рассматривать возможность делать надрезы не только в вертикальной плоскости, 
то сделав последний разрез горизонтально, получим 8 частей
'''

'''
Задачка 7:
У вас есть 2 яйца и 100-этажное здание. Как определить минимальное количество 
бросков, чтобы узнать самый низкий этаж, при падении с которого яйцо разбивается?
'''
#Решение 
'''
Делаем броски, начиная с первого этажа и поднимаемся между бросками на 2 вверх. 
Как только яйцо при броске с этажа n разобьется, спускаемся на этаж n-1 и проверяем его.
'''

'''
Задачка 8:
Стрелочные часы показывают 3:15. Каков угол между минутной и часовой стрелкой?
Ответ: 7.5
'''
# для этой задачи я уже писал код, вычисляющий угол между часовой и минутной стрелкой
def calc(hours: int, minutes: int):
    hour_degrees = 360 / 12 * hours + 360 / 12 / 60 * minutes
    minute_degree = 360 / 60 * minutes
    if hour_degrees >= minute_degree:
        res = hour_degrees - minute_degree
    else:
        res =  minute_degree - hour_degrees
    if res > 180:
        return 360 - res
    return res


print(calc(3, 15))

'''
Задачка 9:
В сумасшедшем доме при выписке наливают ванну воды и дают ложку или кастрюлю на 
выбор. Что нужно выбрать?
'''
#Решение
'''
Для каких целей нужно делать выбор? В вопросе ванна с водой логически не связана
с ложкой или кастрюлей. Не понял суть задания.
'''

'''
Задачка 10:
Водитель с 40-летним стажем в первый раз сел за компьютер. Через 1 минуту он 
пожаловался, что мышь неисправна т.к. курсор мыши двигается только вверх и вниз, 
а вправо и влево нет. Ему произвели замену мыши несколько раз, но ситуация не 
менялась. Не помогла даже переустановка надежной операционной системы windows. 
В чем была причина и как ее исправили?
'''
#Решение
'''
Не смог придумать убедительный ответ, который бы удовлетворил меня.
Приведу свои рассуждения.

Т.к. в задаче говрится, что нет проблем с аппаратной или програмной частью, то
я считаю, что водитель за 40 лет привык, что для перемещения вправо и влево нужно
поворачивать элемент управления. Таким образом по моему мнению, он пытался переместить
курсор по горизонтальной оси вращательными движениями компьютерной мышки.
'''